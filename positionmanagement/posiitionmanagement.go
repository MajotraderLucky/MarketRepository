package positionmanagement

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"math"
	"os"
	"strconv"

	"github.com/MajotraderLucky/MarketRepository/klinesdata"
	"github.com/MajotraderLucky/MarketRepository/positionlog"
)

func Hello() {
	log.Println("Use positionmanagement package")
}

func GetPositionData() (positionAmt string, entryPrice string, err error) {
	autoGeneratedPos := positionlog.GetAutoGeneratedPos()
	positionAmt, entryPrice, err = positionlog.GetPositionData(autoGeneratedPos)
	if err != nil {
		log.Fatalf("Error getting position data: %v", err)
	}
	log.Println("Position Amt: ", positionAmt)
	log.Println("Entry Price: ", entryPrice)

	return positionAmt, entryPrice, nil
}

func ConvertPositionDataToFloat64(positionAmt string, entryPrice string) (float64, float64, error) {
	positionAmtFloat64, err := strconv.ParseFloat(positionAmt, 64)
	if err != nil {
		log.Fatalf("Error converting position amount to float: %v", err)
	}

	entryPriceFloat64, err := strconv.ParseFloat(entryPrice, 64)
	if err != nil {
		log.Fatalf("Error converting entry price to float: %v", err)
	}

	log.Println("Position Amt float64: ", positionAmtFloat64)
	log.Println("Entry Price float64: ", entryPriceFloat64)

	return positionAmtFloat64, entryPriceFloat64, nil
}

func GetFiboLevelStringNow() (string, error) {
	levelStringNow, _ := klinesdata.IsAskPriceHigherThanLongFibRetLog()
	log.Println("Fibo level string now: ", levelStringNow)

	return levelStringNow, nil
}

// -------------------------------------------------------------------------
const (
	LongFib236 = "LongFib236"
	LongFib382 = "LongFib382"
	LongFib500 = "LongFib500"
	LongFib618 = "LongFib618"
	LongFib786 = "LongFib786"
)

func GetFiboLevelFloat64Now() (float64, float64, float64, error) {
	levelStringNow, _ := klinesdata.IsAskPriceHigherThanLongFibRetLog()

	longFiboLevelsFloat64, err := klinesdata.GetFibonacciLevelsReturns()
	if err != nil {
		return 0, 0, 0, fmt.Errorf("error getting Fibonacci level: %v", err)
	}

	if len(longFiboLevelsFloat64) < 5 {
		return 0, 0, 0, errors.New("not enough Fibonacci levels")
	}

	maxFloat64, minFloat64, err := klinesdata.FindMinMaxInfo()

	switch levelStringNow {
	case LongFib236:
		return longFiboLevelsFloat64[0], longFiboLevelsFloat64[1],
			maxFloat64, nil
	case LongFib382:
		return longFiboLevelsFloat64[1], longFiboLevelsFloat64[2],
			longFiboLevelsFloat64[0], nil
	case LongFib500:
		return longFiboLevelsFloat64[2], longFiboLevelsFloat64[3],
			longFiboLevelsFloat64[1], nil
	case LongFib618:
		return longFiboLevelsFloat64[3], longFiboLevelsFloat64[4],
			longFiboLevelsFloat64[2], nil
	case LongFib786:
		return longFiboLevelsFloat64[4], minFloat64,
			longFiboLevelsFloat64[3], nil
	default:
		log.Println("Price is not higher than any Fibonacci level")
		return 0, minFloat64, 0, nil
	}
}

// ------------------------------------------------------------------------

func ConvertFiboLevelsMinMaxToInt() (maxInt64, minInt64, buyOrderInt64,
	lossOrderInt64, profitOrderInt64 int64, err error) {
	maxFloat64, minFloat64, err := klinesdata.FindMinMaxInfo()
	if err != nil {
		return 0, 0, 0, 0, 0, err
	}
	maxInt64 = int64(math.Round(maxFloat64))
	minInt64 = int64(math.Round(minFloat64))

	buyOrderFloat64, lossOrderFloat64, profitOrderFloat64, err := GetFiboLevelFloat64Now()
	buyOrderInt64 = int64(math.Round(buyOrderFloat64))
	lossOrderInt64 = int64(math.Round(lossOrderFloat64))
	profitOrderInt64 = int64(math.Round(profitOrderFloat64))

	return maxInt64, minInt64, buyOrderInt64, lossOrderInt64, profitOrderInt64, nil
}

func GetStopLossOrderPrice(r io.Reader) (string, int64, error) {
	file, err := os.Open("logs/orders.json")
	if err != nil {
		return "", 0, err
	}
	defer file.Close()

	var orders []struct {
		StopPrice string `json:"stopPrice"`
		OrderId   int64  `json:"orderId"`
	}

	// Читаем данные из файла
	if err := json.NewDecoder(file).Decode(&orders); err != nil {
		return "", 0, err
	}

	// Если r является io.Seeker, устанавливаем позицию чтения в начало
	if seeker, ok := r.(io.Seeker); ok {
		_, err := seeker.Seek(0, io.SeekStart)
		if err != nil {
			return "", 0, err
		}
	}

	// Читаем данные из r
	if err := json.NewDecoder(r).Decode(&orders); err != nil {
		return "", 0, err
	}

	// Ищем ордер с типом "StopPrice" и "OrderId"
	for _, order := range orders {
		if order.StopPrice != "" && order.OrderId != 0 {
			return order.StopPrice, order.OrderId, nil
		}
	}

	// Если не нашли ни одного ордера с типом "StopPrice" и "OrderId",
	// то возвращаем ошибку
	return "", 0, errors.New("No stop market order detected")
}

func GetStopOrderPriceAndId() (string, int64, error) {
	// Открываем файл
	file, err := os.Open("logs/orders.json")
	if err != nil {
		// Если произошла ошибка при открытии файла, возвращаем ошибку
		return "", 0, err
	}
	defer file.Close()

	// Получаем данные из файла с использованием другой функции (GetStopLossOrderPrice)
	stopOrderPriceFromJsonFile, stopOrderIdFromJsonFile, err := GetStopLossOrderPrice(file)

	if err != nil {
		// Если произошла ошибка при получении данных из файла, возвращаем ошибку
		return "", 0, err
	}

	// Возвращаем полученные данные
	return stopOrderPriceFromJsonFile, stopOrderIdFromJsonFile, nil
}
